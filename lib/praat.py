import parselmouth
import numpy as np

def get_pulses(y, fs):
    """Get sample indices of pulses according to Praat heuristics"""
    s = parselmouth.Sound(y, sampling_frequency=fs) # `fs` must be in Hz

    pitch = s.to_pitch()
    pp = parselmouth.praat.call([s, pitch], "To PointProcess (cc)")
    pulses = parselmouth.praat.call(pp, "To Matrix").values[0,:] # Always take pulses from left channel if stereo
    return np.asarray(pulses*fs, dtype=int) # Convert to sample indices

def get_formants(y, fs, formants=(1,2,3,4), max_number_of_formants=5, maximum_formant=5500.):
    """Get formant estimates using Praat heuristics and Burg's method

    Praat windows the signal, and calculates the F[i] and B[i] for each window.
    Though we set the window length equal to the length of the whole signal, multiple windows (two)
    are nevertheless used. Go figure. The center times of the windows are in `F.t_grid`.
    We ask the F[i] and B[i] at the center time; these are generated by linear interpolation. Maybe
    this is why Praat uses two windows -- to be able to interpolate.
    
    Args:
        y (array): Samples
        fs (int): Sampling frequency in Hz
        formants (tuple): Get the frequency and bandwidths from these formants and
            in this order
        max_number_of_formants (int): Praat option
        maximum_formant (int): Praat option
    
    Returns:
        freq (array): Formant frequencies in Hz
        bw (array): Formant bandwidths in Hz
    """
    s = parselmouth.Sound(y, sampling_frequency=fs)
    
    F = s.to_formant_burg(max_number_of_formants=max_number_of_formants,
                          maximum_formant=maximum_formant, window_length=s.duration)
    
    freq = np.fromiter((F.get_value_at_time(i, F.centre_time) for i in formants), float)
    bw = np.fromiter((F.get_bandwidth_at_time(i, F.centre_time) for i in formants), float)
    
    return freq, bw